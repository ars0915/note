id:: 9e305e92-ab7d-413c-b20d-8da2c012771b

- # 雷亞面試考古 [[雷亞面試安排]]
	- Pointer
		- Pointer 是儲存變數在記憶體的位置，透過傳遞 pointer 可以減少 copy 的資料夾，並且直接改動到原本的值
		- **Pointer 可能是 nil/null，需要檢查避免 panic**
		- **在 Go 中，pointer 還涉及 escape analysis（編譯器決定變數該放 stack 還是 heap)**
	- Stack memory vs Heap memory
		- stack 是 LIFO 的堆疊，用來儲存參數、local variable 和 thread 執行 function 時追蹤的其他資料,  呼叫 function 時會 push 一個 frame, return 時會 pop, pop 時**透過移動 stack pointer 安全的釋放記憶體**, **stack 上的資料生命週期受限於 function scope，return 後該 stack frame 就被回收**。 thread stack 是固定的，如果超過限制就會 stack overflow。
		- heap 分配的記憶體不能在 return 時釋放, 所以要避免 leak 和 fragmentation, heap 比 Stack 大很多倍。golang 的所有 goroutin 共享一個 heap，沒辦法存在 Stack 的東西都在裡面, alloc 就用來記錄引用，GC 就是稍後會釋放不再引用的 heap 變數
		- **Stack allocation 更快，因為只需移動 stack pointer**
		- **Heap allocation 需要找到足夠大的連續空間，所以較慢**
		- **Go 的 escape analysis 會自動決定變數要放哪裡（例如 return 一個 local variable 的 pointer 時，該變數會被放到 heap）**
	- Process vs Thread
		- process 是在 OS 上執行的一個程式，thread 則是程序，在一個程式中可能會開啟多個 thread 做並行的處理
		- **Process: 擁有獨立的記憶體空間（code, data, heap, stack）、file descriptors、獨立的資源**
		- **Thread: 共享同一個 process 的記憶體空間（heap, code, data），但各自有獨立的 stack 和 registers**
		- **Thread 間切換成本比 process 低（因為不需要切換記憶體映射）**
		- **Process 間通信需要 IPC（pipe, socket, shared memory），thread 間可以直接存取共享記憶體**
	- **Context switch**
		- 在不同的 **process 或 thread** 之間切換執行
		- 需要保存當前的 CPU 狀態（registers, program counter, stack pointer 等）
		- 載入下一個要執行的 process/thread 的狀態
		- 成本包括：直接成本（保存/恢復狀態）+ 間接成本（cache miss, TLB flush）
		- Go 的 goroutine 比 OS thread 輕量，因為它們在 user space 做 scheduling，減少了 kernel context switch
	- **Mode Switch**（user/kernel mode）是另一個概念：
		- 當 process 需要執行 system call 或處理 interrupt 時發生
		- 從 user mode 切換到 kernel mode（或反之）
		- 這通常會發生在同一個 process 內
- # 記憶體相關
	- Memory Leak
		- **定義：**
		  程式分配的記憶體無法被釋放，持續累積導致可用記憶體減少。
		- **C/C++ 常見原因：**
			- 忘記 free/delete
			- Double free
			- 指標遺失（分配後沒保存 pointer）
		- **Go 常見原因：**
		  即使有 GC，還是可能 leak：
			- Goroutine leak：goroutine 一直 block 無法結束
			- 保持對不再需要的大物件的引用（例如 slice 只用一小部分，但整個底層 array 被保留）
			- Timer/Ticker 沒有 Stop
			- Global map 持續增長沒清理
- # 並發相關
	- Race Condition
		- **定義：**
		  多個 thread/goroutine 同時存取共享資源，且至少有一個是寫入操作，導致結果取決於執行順序。
		- **如何避免：**
			- 使用 Mutex/RWMutex
			- 使用 atomic operations
			- 使用 channel 傳遞資料（Go 的推薦方式："share memory by communicating"）
	- Deadlock
		- **定義：**
		  兩個或多個 thread/goroutine 互相等待對方釋放資源，導致全部卡住。
		- **四個必要條件（破除任一即可避免）：**
			- Mutual exclusion（互斥）
			- Hold and wait（持有並等待）
			- No preemption（不可搶奪）
			- Circular wait（循環等待）
		- **常見避免方式：**
			- 固定 lock 的順序（總是先鎖 A 再鎖 B）
			- Timeout 機制
			- 使用 higher-level 的同步機制（如 channel）
	- Mutex vs Semaphore
		- **Mutex（Mutual Exclusion）：**
			- Binary lock（只有 locked/unlocked）
			- 同一個 thread 鎖定和解鎖
			- 用途：保護 critical section
			  
			  ```go
			  var mu sync.Mutex
			  mu.Lock()
			  *// critical section*
			  mu.Unlock()
			  ```
		- **Semaphore：**
			- 計數器（可以有多個 permits）
			- 任何 thread 都可以 signal
			- 用途：限制同時存取資源的數量
			  ```go
			  *// Go 沒有內建 semaphore，但可以用 buffered channel 模擬*
			  sem := make(chan struct{}, 3)  *// 最多 3 個並發*
			  
			  sem <- struct{}{}  *// acquire*
			  *// do work*
			  <-sem             *// release*
			  ```
		- **主要差異：**
			- Mutex: 所有權概念，誰鎖就誰解
			- Semaphore: 計數概念，可以多個 permits
- # API
	- ### gRPC 跟 REST 的差異，為什麼能加速
		- gRPC 用 HTTP/2 和 Protocol Buffers，比 REST 的 HTTP/1.1 + JSON 更快，主要是因為 binary serialization、multiplexing 和 streaming。
		- 第一，gRPC 用 Protocol Buffers 而不是 JSON。Protocol Buffers 是 binary format，比 JSON 小 2-3 倍，序列化也快很多。
		- 第二，gRPC 基於 HTTP/2，有 multiplexing 功能，可以在單一 TCP 連線上並行多個請求，減少連線建立的 overhead。
		- 第三，HTTP/2 有 header compression，重複的 headers 不用每次都送。
		- 我在 Mlytics 做過 REST 到 gRPC 的遷移。在高 throughput 場景（400K msg/sec），這些優化的效果很明顯，latency 降低了，CPU 使用也更有效率。"
	- ### HTTP/2 還有什麼其他好處?
		- Server push
		- Stream prioritization
		- Better compression
- # [[MQ]]
	- ## 你的團隊反應 Kafka Consumer 經常發生 rebalance，導致消息處理延遲。可能的原因有哪些？你會如何優化？
		- 最常見的 3 個原因
			- Consumer 處理時間太長
			  ```go
			  // 問題：Consumer 處理一批訊息超過 max.poll.interval.ms（預設 5 分鐘）
			  for msg := range messages {
			      processMessage(msg)  // 如果這個很慢...
			  }
			  // → Coordinator 認為 Consumer 掛了 → 觸發 rebalance
			  
			  // 解決方案：
			  props.put("max.poll.interval.ms", 600000)  // 增加到 10 分鐘
			  props.put("max.poll.records", 100)         // 減少每次拉取的數量
			  ```
			- session.timeout.ms 設定太短
			  ```go
			  // 問題：Consumer 的心跳超時
			  props.put("session.timeout.ms", 10000)  // 10 秒太短
			  
			  // 解決方案：
			  props.put("session.timeout.ms", 30000)      // 增加到 30 秒
			  props.put("heartbeat.interval.ms", 3000)    // 心跳間隔 3 秒
			  ```
			- Consumer 實例頻繁啟動/關閉
			  ```go
			  // 問題：部署、擴縮容觸發 rebalance
			  
			  // 解決方案（你提到的）：
			  props.put("group.instance.id", "consumer-1")  // Static Membership
			  ```
		- 另外，Kafka 2.4+ 可以用 Cooperative Rebalancing 減少 stop-the-world 的影響
- # [[DB]]
- # [[lock]]
- # [[Algorithm]]
- # [[Kubernetes]]
- # [[golang]]
- # [[System Design]]
	- 這應該獨立出來作為重點項目
	- 遊戲後端相關：匹配系統、排行榜、聊天系統、玩家狀態同步
	- 高併發、負載均衡、CAP theory
- # [[Cache]]
- # 網路基礎
	- TCP/UDP 差異（遊戲後端很常問）
	- WebSocket
	- HTTP/1.1 vs HTTP/2 vs HTTP/3
- # 安全性基礎
	- Authentication vs Authorization
	- JWT, OAuth 2.0
	- 常見攻擊：SQL Injection, XSS, CSRF
	- Rate limiting, DDoS 防護
- # 測試與監控
	- 單元測試、整合測試
	- Prometheus, Grafana（結合你現在公司缺乏監控的痛點）
	- 分散式追蹤（Jaeger, Zipkin）
- # 時程
- 【Week 1：基礎 + System Design】
	- Day 1: DB + Cache
	  ├─ 早上：LeetCode 複習 3 題
	  ├─ 下午：DB（索引、隔離級別）
	  └─ 晚上：Cache（四種策略、三大問題）+ 複習 2 題
		- 88. merge-sorted-array (**Two Pointers**)
		- 26. remove-element(**Two Pointers**)
		- 27. Remove Element(**Two Pointers**)
		- ⚠️ 80. remove-duplicates-from-sorted-array(**Two Pointers**)
		  id:: 6908a472-512b-4b1c-9842-3081e240c93b
		- ⚠️ 148. Sort List (**Linked List**, **Two Pointers**,  **Merge Sort**)
	- Day 2: MQ + Kafka
	  ├─ 下午：MQ + Kafka Partition/Rebalance
	- Day 3: Golang 並發
	  ├─ 早上：LeetCode 複習 3 題
	  ├─ 下午：sync.Pool, Once, Slice 陷阱
	  └─ 晚上：Context + Worker Pool + 複習 2 題
	- Day 4: 網路 + K8s
	  ├─ 早上：LeetCode 複習 3 題
	  ├─ 下午：TCP/UDP, WebSocket, K8s 基本概念
	  └─ 晚上：安全基礎 + 複習 2 題 + Lock 複習
	  Day 5: System Design - 匹配 + 排行榜
	  ├─ 早上：開始 Binary Search 新題 2 題 + 複習 2 題
	  ├─ 下午：匹配系統設計
	  └─ 晚上：排行榜系統 + Binary Search 1 題
	  Day 6: System Design - 聊天
	  ├─ 早上：Binary Search 新題 2 題 + 複習 3 題
	  ├─ 下午：聊天系統設計
	  └─ 晚上：玩家狀態同步（如果要加）
	- Day 7: System Design 模擬 + 6.824 開始
	  ├─ 早上：DP 新題 2 題（70, 198）+ 複習 3 題
	  ├─ 下午：System Design 模擬面試
	  └─ 晚上：開始複習 6.824 筆記（Raft, CAP）
- 【Week 2：6.824 + LeetCode 衝刺】
	- Day 8: 6.824
	  ├─ 早上：DP 新題 2 題 + 複習 3 題
	  ├─ 下午：6.824 筆記（一致性模型、分散式鎖）
	  └─ 晚上：DP 新題 1 題（139 或 300）
	- Day 9: 主攻 LeetCode DP
	  ├─ 早上：DP 新題 2 題（300, 322）+ 複習 3 題
	  ├─ 下午：DP 新題 1-2 題（152 或 5）
	  └─ 晚上：複習 DP + 之前的題
	- Day 10: 主攻 LeetCode Backtracking
	  ├─ 早上：Backtracking 新題 2 題（46, 78）+ 複習 3 題
	  ├─ 下午：Backtracking 新題 2 題（39, 17）
	  └─ 晚上：複習 Backtracking
	- Day 11: Graph + 你被考過的題
	  ├─ 早上：Graph 新題 2 題（133, 207）+ 複習 3 題
	  ├─ 下午：複習你被考過的題（Fill Question Marks, Sum of Edges）
	  └─ 晚上：LeetCode 複習重點題
	  Day 12: 總複習 - 基礎知識
	  ├─ 早上：LeetCode 複習 5 題（重點 Medium）
	  ├─ 下午：快速過一遍所有基礎筆記
	  └─ 晚上：LeetCode 複習 5 題
	  Day 13: 總複習 - System Design + 6.824
	  ├─ 早上：LeetCode 複習 5 題
	  ├─ 下午：System Design 三個場景快速過一遍
	  └─ 晚上：6.824 重點概念複習