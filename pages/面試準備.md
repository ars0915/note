public:: true

- # 雷亞面試考古 [[雷亞面試安排]]
	- Pointer
		- Pointer 是儲存變數在記憶體的位置，透過傳遞 pointer 可以減少 copy 的資料夾，並且直接改動到原本的值
		- **Pointer 可能是 nil/null，需要檢查避免 panic**
		- **在 Go 中，pointer 還涉及 escape analysis（編譯器決定變數該放 stack 還是 heap)**
	- Stack memory vs Heap memory
		- stack 是 LIFO 的堆疊，用來儲存參數、local variable 和 thread 執行 function 時追蹤的其他資料,  呼叫 function 時會 push 一個 frame, return 時會 pop, pop 時**透過移動 stack pointer 安全的釋放記憶體**, **stack 上的資料生命週期受限於 function scope，return 後該 stack frame 就被回收**。 thread stack 是固定的，如果超過限制就會 stack overflow。
		- heap 分配的記憶體不能在 return 時釋放, 所以要避免 leak 和 fragmentation, heap 比 Stack 大很多倍。golang 的所有 goroutin 共享一個 heap，沒辦法存在 Stack 的東西都在裡面, alloc 就用來記錄引用，GC 就是稍後會釋放不再引用的 heap 變數
		- **Stack allocation 更快，因為只需移動 stack pointer**
		- **Heap allocation 需要找到足夠大的連續空間，所以較慢**
		- **Go 的 escape analysis 會自動決定變數要放哪裡（例如 return 一個 local variable 的 pointer 時，該變數會被放到 heap）**
	- Process vs Thread
		- process 是在 OS 上執行的一個程式，thread 則是程序，在一個程式中可能會開啟多個 thread 做並行的處理
		- **Process: 擁有獨立的記憶體空間（code, data, heap, stack）、file descriptors、獨立的資源**
		- **Thread: 共享同一個 process 的記憶體空間（heap, code, data），但各自有獨立的 stack 和 registers**
		- **Thread 間切換成本比 process 低（因為不需要切換記憶體映射）**
		- **Process 間通信需要 IPC（pipe, socket, shared memory），thread 間可以直接存取共享記憶體**
	- **Context switch**
		- 在不同的 **process 或 thread** 之間切換執行
		- 需要保存當前的 CPU 狀態（registers, program counter, stack pointer 等）
		- 載入下一個要執行的 process/thread 的狀態
		- 成本包括：直接成本（保存/恢復狀態）+ 間接成本（cache miss, TLB flush）
		- Go 的 goroutine 比 OS thread 輕量，因為它們在 user space 做 scheduling，減少了 kernel context switch
	- **Mode Switch**（user/kernel mode）是另一個概念：
		- 當 process 需要執行 system call 或處理 interrupt 時發生
		- 從 user mode 切換到 kernel mode（或反之）
		- 這通常會發生在同一個 process 內
- # 記憶體相關
	- Memory Leak
		- **定義：**
		  程式分配的記憶體無法被釋放，持續累積導致可用記憶體減少。
		- **C/C++ 常見原因：**
			- 忘記 free/delete
			- Double free
			- 指標遺失（分配後沒保存 pointer）
		- **Go 常見原因：**
		  即使有 GC，還是可能 leak：
			- Goroutine leak：goroutine 一直 block 無法結束
			- 保持對不再需要的大物件的引用（例如 slice 只用一小部分，但整個底層 array 被保留）
			- Timer/Ticker 沒有 Stop
			- Global map 持續增長沒清理
- # 並發相關
	- Race Condition
		- **定義：**
		  多個 thread/goroutine 同時存取共享資源，且至少有一個是寫入操作，導致結果取決於執行順序。
		- **如何避免：**
			- 使用 Mutex/RWMutex
			- 使用 atomic operations
			- 使用 channel 傳遞資料（Go 的推薦方式："share memory by communicating"）
	- Deadlock
		- **定義：**
		  兩個或多個 thread/goroutine 互相等待對方釋放資源，導致全部卡住。
		- **四個必要條件（破除任一即可避免）：**
			- Mutual exclusion（互斥）
			- Hold and wait（持有並等待）
			- No preemption（不可搶奪）
			- Circular wait（循環等待）
		- **常見避免方式：**
			- 固定 lock 的順序（總是先鎖 A 再鎖 B）
			- Timeout 機制
			- 使用 higher-level 的同步機制（如 channel）
	- Mutex vs Semaphore
		- **Mutex（Mutual Exclusion）：**
			- Binary lock（只有 locked/unlocked）
			- 同一個 thread 鎖定和解鎖
			- 用途：保護 critical section
			  
			  ```go
			  var mu sync.Mutex
			  mu.Lock()
			  *// critical section*
			  mu.Unlock()
			  ```
		- **Semaphore：**
			- 計數器（可以有多個 permits）
			- 任何 thread 都可以 signal
			- 用途：限制同時存取資源的數量
			  ```go
			  *// Go 沒有內建 semaphore，但可以用 buffered channel 模擬*
			  sem := make(chan struct{}, 3)  *// 最多 3 個並發*
			  
			  sem <- struct{}{}  *// acquire*
			  *// do work*
			  <-sem             *// release*
			  ```
		- **主要差異：**
			- Mutex: 所有權概念，誰鎖就誰解
			- Semaphore: 計數概念，可以多個 permits
- # API
	- ### gRPC 跟 REST 的差異，為什麼能加速
		- gRPC 用 HTTP/2 和 Protocol Buffers，比 REST 的 HTTP/1.1 + JSON 更快，主要是因為 binary serialization、multiplexing 和 streaming。
		- 第一，gRPC 用 Protocol Buffers 而不是 JSON。Protocol Buffers 是 binary format，比 JSON 小 2-3 倍，序列化也快很多。
		- 第二，gRPC 基於 HTTP/2，有 multiplexing 功能，可以在單一 TCP 連線上並行多個請求，減少連線建立的 overhead。
		- 第三，HTTP/2 有 header compression，重複的 headers 不用每次都送。
		- 我在 Mlytics 做過 REST 到 gRPC 的遷移。在高 throughput 場景（400K msg/sec），這些優化的效果很明顯，latency 降低了，CPU 使用也更有效率。"
	- ### HTTP/2 還有什麼其他好處?
		- Server push
		- Stream prioritization
		- Better compression
- # MQ
	- ## RabbitMQ 跟 kafka 差異
		- **一句話回答：**
		  "RabbitMQ 是傳統 message broker，適合複雜路由和保證送達；Kafka 是 distributed streaming platform，適合高吞吐量和 event sourcing。"
	- ## 詳細對比
		- #### A. 設計理念
			- | 特性 | RabbitMQ | Kafka |
			  |------|----------|-------|
			  | **定位** | Message Broker | Distributed Log |
			  | **使用場景** | Task queue, RPC | Event streaming, Log aggregation |
			  | **訊息模型** | Push (broker push to consumer) | Pull (consumer pull from broker) |
			  | **訊息保留** | 消費後刪除 | 保留一段時間（可設定） |
			  | **順序保證** | Queue level | Partition level |
		- #### B. 架構差異
			- **RabbitMQ:**
			  ```
			  Producer → Exchange → Queue(s) → Consumer(s)
			             ↓
			          (routing)
			  ```
				- **Exchange types**: Direct, Topic, Fanout, Headers
				- **複雜路由**：可以用 routing key 做靈活的訊息分配
				- **Multiple queues per consumer**
			- **Kafka:**
			  ```
			  Producer → Topic (multiple partitions) → Consumer Group
			  ```
				- **Simple routing**：只有 topic 和 partition
				- **Partition = ordered log**
				- **Replication** 內建
		- #### C. 使用場景對比
			- **RabbitMQ 適合：**
				- 1. **Task Queue**
					- Worker pattern
					- 保證 exactly-once processing（搭配 acknowledgment）
				- 2. **複雜 Routing**
					- 需要根據 routing key 送到不同 queue
					- Topic exchange 做靈活的訂閱
				- 3. **RPC Pattern**
					- Request-reply 模式
					- 需要回覆的場景
				- 4. **低延遲優先**
					- Sub-millisecond latency
			- **Kafka 適合：**
				- 1. **High Throughput**
					- 每秒處理百萬級訊息
				- 2. **Event Sourcing**
					- 需要保留所有 events
					- Event replay
				- 3. **Log Aggregation**
					- 收集大量 logs
					- 數據 pipeline
				- 4. **Stream Processing**
					- Real-time analytics
					- Data transformation
	- #### D. 核心技術差異
		- **1. Message 保留**
		  ```
		  RabbitMQ:
		  Producer → Queue → Consumer → [Message deleted]
		  
		  Kafka:
		  Producer → Partition → Consumers → [Message still there]
		                                    (保留 7 days)
		  ```
		  
		  **影響：**
			- RabbitMQ: 消費後訊息就沒了，不能 replay
			- Kafka: 可以 replay，可以讓新的 consumer 從頭讀
		- **2. Consumer 模型**
		  ```
		  RabbitMQ - Push:
		  Broker 主動推給 Consumer
		  → Consumer 需要處理 back pressure
		  
		  Kafka - Pull:
		  Consumer 主動拉取
		  → Consumer 控制速度
		  → 可以 batch 拉取
		  ```
		- **3. Ordering**
		  ```
		  RabbitMQ:
		  在 single queue 內保證順序
		  Multiple consumers 可能打亂
		  - Kafka:
		  在 single partition 內保證順序
		  Partition key 決定哪個 partition
		  ```
		- **4. Scalability**
		  ```
		  RabbitMQ:
		  Vertical scaling (單機效能)
		  Clustering 有限
		  - Kafka:
		  Horizontal scaling (加 broker)
		  Partition 分散負載
		  ```
	- ## 面試回答模板
		- ### 什麼時候用 RabbitMQ，什麼時候用 Kafka
			- 用 RabbitMQ：
				- Task queue（worker pattern）
				- 需要複雜 routing
				- RPC pattern
				- 低延遲更重要
			- 用 Kafka：
				- High throughput（百萬 msg/sec）
				- 需要 replay events
				- Event sourcing
				- Log aggregation
				- Data pipeline
		- ### Kafka 的 Consumer Group 是什麼？
			- Consumer Group 讓多個 consumer 共同消費一個 topic。
			- Key 概念：
				- 同一個 group 內，每個 partition 只能被一個 consumer 消費
				- 不同 group 可以獨立消費同一個 topic
				- 用來做 horizontal scaling
				  
				  比如有 Topic 有 4 個 partitions，Consumer Group 有 2 個 consumers，那麼每個 consumer 會負責 2 個 partitions。"
		- ### RabbitMQ 的 Exchange 類型？
			- 1. Direct: 完全匹配 routing key
			  2. Topic: Pattern 匹配 `(用 * 和 #)`
			  3. Fanout: 廣播給所有綁定的 queue
			  4. Headers: 根據 message headers 路由
		- ### Kafka 的 replication 怎麼運作？
			- Leader/Follower
			- ISR (In-Sync Replicas)
			- 保證 durability
		- ### RabbitMQ 怎麼保證訊息不丟？
			- Publisher confirms
			- Consumer acknowledgments
			- Durable queues
			- Persistent messages
- # [[DB]]
	- SQL, noSQL
	- ndex 原理與優化（B+ Tree）
	- 交易、隔離級別
	- 正規化、Schema 設計
	- MySQL vs PostgreSQL 差異
- # [[lock]]
- # [[Algorithm]]
- # [[Kafka]]
- # [[Kubernetes]]
- # [[golang]]
	- goroutine GMP
		- **基本概念要能說出來：**
			- **G (Goroutine)**：用戶態的輕量級執行緒
			- **M (Machine)**：OS 執行緒
			- **P (Processor)**：邏輯處理器，持有 G 的佇列
		- **核心優勢**：M:N 調度模型，一個 M 可以執行多個 G
	- Goroutine Leak 怎麼避免？
		- channel 沒關閉
		- context 沒取消
		- 死鎖情況
	- Channel 的使用與原理
		- buffered vs unbuffered
		- close 的時機
		- select 的使用
	- sync 包的使用
		- WaitGroup、Mutex、RWMutex
		- Once、Pool
		- 什麼時候用 channel，什麼時候用 mutex？
	- Context 的傳遞與取消
		- 超時控制
		- 優雅關閉
	- 常見並發問題
		- Race condition 怎麼 debug？
		- 如何控制 goroutine 數量？（worker pool）
	- panic
		- `recover()` **必須**在 `defer` 函數中呼叫
		  ```go
		  func wrong2() {
		      defer recover() // ❌ 無效！recover 必須在「函數呼叫」中
		      panic("test")
		  }
		  
		  // 正確寫法
		  func correct() {
		      defer func() {
		          recover() // ✅ 在匿名函數中呼叫
		      }()
		      panic("test")
		  }
		  ```
		- panic 發生後，當前函數會立即停止，開始執行 defer 棧
		- recover 要跟 panic 在同一個 goroutine 才會被觸發
		- 如果沒有 recover，panic 會向上傳播直到程式崩潰
		- defer 是 **LIFO（後進先出）** 棧
		- 適合用 panic 的場景：
			- **初始化階段的致命錯誤**（如設定檔載入失敗）
			- **程式設計錯誤**（如除以零、陣列越界）
			- **不可恢復的錯誤**（如記憶體分配失敗）
		- 不應該用 panic 的場景：
			- **正常的錯誤處理**（應該用 `error` 回傳）
			- **可預期的失敗**（如網路請求失敗、檔案不存在）
			- **業務邏輯錯誤**
		- **面試標準答案：**
			- "Go 提倡用 error 處理錯誤，panic 應該只用在真正無法恢復的異常情況。在函式庫開發中，幾乎不應該讓 panic 傳播給呼叫者，應該 recover 後轉成 error 回傳。"
	- channel
		- Unbuffered Channel
			- 在每次要傳送或接收前都必需進行等待
			  對於一個沒有 buffer 的 channel ，channel 上一次只能有一個值，前一個傳完，才能傳下一個，不能允許一次上傳超過一個
		- buffered Channel
			- 如果是有 buffer 的 channel 那麼就 **不必在意對方是否接收到** ，只要在以是否仍有足夠的緩充空間，如果沒有空間了才會進行等待。
		- 接收不確定個數的 channel
			- 因此可以利用 `for + range` 來接收 channel 上的值，但是要注意一點，傳送最後一個值後必需利用 `close()` 將 channel 關閉，golang 才知道這是最後一個值
- # [[System Design]]
	- 這應該獨立出來作為重點項目
	- 遊戲後端相關：匹配系統、排行榜、聊天系統、玩家狀態同步
	- 高併發、負載均衡、CAP theory
- # [[Cache]]
	- Redis：資料結構、過期策略、持久化
	- 快取穿透/擊穿/雪崩的解決方案
	- 分散式快取的一致性問題
- # 網路基礎
	- TCP/UDP 差異（遊戲後端很常問）
	- WebSocket
	- HTTP/1.1 vs HTTP/2 vs HTTP/3
- # 安全性基礎
	- Authentication vs Authorization
	- JWT, OAuth 2.0
	- 常見攻擊：SQL Injection, XSS, CSRF
	- Rate limiting, DDoS 防護
- # 測試與監控
	- 單元測試、整合測試
	- Prometheus, Grafana（結合你現在公司缺乏監控的痛點）
	- 分散式追蹤（Jaeger, Zipkin）