# 雷亞面試考古
	- Pointer
		- Pointer 是儲存變數在記憶體的位置，透過傳遞 pointer 可以減少 copy 的資料夾，並且直接改動到原本的值
		- **Pointer 可能是 nil/null，需要檢查避免 panic**
		- **在 Go 中，pointer 還涉及 escape analysis（編譯器決定變數該放 stack 還是 heap)**
	- Stack memory vs Heap memory
		- stack 是 LIFO 的堆疊，用來儲存參數、local variable 和 thread 執行 function 時追蹤的其他資料,  呼叫 function 時會 push 一個 frame, return 時會 pop, pop 時**透過移動 stack pointer 安全的釋放記憶體**, **stack 上的資料生命週期受限於 function scope，return 後該 stack frame 就被回收**。 thread stack 是固定的，如果超過限制就會 stack overflow。
		- heap 分配的記憶體不能在 return 時釋放, 所以要避免 leak 和 fragmentation, heap 比 Stack 大很多倍。golang 的所有 goroutin 共享一個 heap，沒辦法存在 Stack 的東西都在裡面, alloc 就用來記錄引用，GC 就是稍後會釋放不再引用的 heap 變數
		- **Stack allocation 更快，因為只需移動 stack pointer**
		- **Heap allocation 需要找到足夠大的連續空間，所以較慢**
		- **Go 的 escape analysis 會自動決定變數要放哪裡（例如 return 一個 local variable 的 pointer 時，該變數會被放到 heap）**
	- Process vs Thread
		- process 是在 OS 上執行的一個程式，thread 則是程序，在一個程式中可能會開啟多個 thread 做並行的處理
		- **Process: 擁有獨立的記憶體空間（code, data, heap, stack）、file descriptors、獨立的資源**
		- **Thread: 共享同一個 process 的記憶體空間（heap, code, data），但各自有獨立的 stack 和 registers**
		- **Thread 間切換成本比 process 低（因為不需要切換記憶體映射）**
		- **Process 間通信需要 IPC（pipe, socket, shared memory），thread 間可以直接存取共享記憶體**
	- **Context switch**
		- 在不同的 **process 或 thread** 之間切換執行
		- 需要保存當前的 CPU 狀態（registers, program counter, stack pointer 等）
		- 載入下一個要執行的 process/thread 的狀態
		- 成本包括：直接成本（保存/恢復狀態）+ 間接成本（cache miss, TLB flush）
		- Go 的 goroutine 比 OS thread 輕量，因為它們在 user space 做 scheduling，減少了 kernel context switch
	- **Mode Switch**（user/kernel mode）是另一個概念：
		- 當 process 需要執行 system call 或處理 interrupt 時發生
		- 從 user mode 切換到 kernel mode（或反之）
		- 這通常會發生在同一個 process 內
- # 記憶體相關
	- Memory Leak
		- **定義：**
		  程式分配的記憶體無法被釋放，持續累積導致可用記憶體減少。
		- **C/C++ 常見原因：**
			- 忘記 free/delete
			- Double free
			- 指標遺失（分配後沒保存 pointer）
		- **Go 常見原因：**
		  即使有 GC，還是可能 leak：
			- Goroutine leak：goroutine 一直 block 無法結束
			- 保持對不再需要的大物件的引用（例如 slice 只用一小部分，但整個底層 array 被保留）
			- Timer/Ticker 沒有 Stop
			- Global map 持續增長沒清理
- # 並發相關
	- Race Condition
		- **定義：**
		  多個 thread/goroutine 同時存取共享資源，且至少有一個是寫入操作，導致結果取決於執行順序。
		- **如何避免：**
			- 使用 Mutex/RWMutex
			- 使用 atomic operations
			- 使用 channel 傳遞資料（Go 的推薦方式："share memory by communicating"）
	- Deadlock
		- **定義：**
		  兩個或多個 thread/goroutine 互相等待對方釋放資源，導致全部卡住。
		- **四個必要條件（破除任一即可避免）：**
			- Mutual exclusion（互斥）
			- Hold and wait（持有並等待）
			- No preemption（不可搶奪）
			- Circular wait（循環等待）
		- **常見避免方式：**
			- 固定 lock 的順序（總是先鎖 A 再鎖 B）
			- Timeout 機制
			- 使用 higher-level 的同步機制（如 channel）
	- Mutex vs Semaphore
		- **Mutex（Mutual Exclusion）：**
			- Binary lock（只有 locked/unlocked）
			- 同一個 thread 鎖定和解鎖
			- 用途：保護 critical section
			  
			  ```go
			  var mu sync.Mutex
			  mu.Lock()
			  *// critical section*
			  mu.Unlock()
			  ```
		- **Semaphore：**
			- 計數器（可以有多個 permits）
			- 任何 thread 都可以 signal
			- 用途：限制同時存取資源的數量
			  ```go
			  *// Go 沒有內建 semaphore，但可以用 buffered channel 模擬*
			  sem := make(chan struct{}, 3)  *// 最多 3 個並發*
			  
			  sem <- struct{}{}  *// acquire*
			  *// do work*
			  <-sem             *// release*
			  ```
		- **主要差異：**
			- Mutex: 所有權概念，誰鎖就誰解
			- Semaphore: 計數概念，可以多個 permits
- # Golang 的鎖
	- sync.Mutex
		- 互斥鎖，同時只能一個 goroutine 持有
		- Lock/Unlock 必須成對
	- sync.RWMutex
		- 讀寫鎖
		- 多個 reader 可同時持有（RLock）
		- 只能一個 writer 持有（Lock）
		- Writer 會 block 所有 readers 和 writers
		- 適用場景：讀多寫少
		  ```go
		  var rwmu sync.RWMutex
		  
		  *// Reader*
		  rwmu.RLock()
		  *// read data*
		  rwmu.RUnlock()
		  
		  *// Writer*
		  rwmu.Lock()
		  *// write data*
		  rwmu.Unlock()
		  ```
		- 排序邏輯
			- 多個 Reader 並發：如果沒有 Writer 在等待，所有 Reader 都可以同時獲取鎖
			- Writer 獨佔：Writer 必須等所有 Reader 都釋放鎖後才能獲取
			- 防止 Writer Starvation：當有 Writer 在等待時，**新來的 Reader 會被阻塞**
		- ##
	- atomic operations
		- 不算是鎖，但可用於簡單的原子操作
		- 比 Mutex 更快
		- 只適用於簡單類型（int, pointer 等）
		  
		  ```go
		  var counter int64
		  atomic.AddInt64(&counter, 1)
		  value := atomic.LoadInt64(&counter)
		  ```
	- sync.Map
		- Thread-safe 的 map
		- 內部已經處理好同步
		- 適用於讀多寫少的場景
	- **選擇建議：**
		- 簡單計數器 → atomic
		- 保護單一資源 → Mutex
		- 讀多寫少 → RWMutex
		- 優先考慮用 channel 來設計（"share memory by communicating"）
-