# 雷亞面試考古
	- Pointer
		- Pointer 是儲存變數在記憶體的位置，透過傳遞 pointer 可以減少 copy 的資料夾，並且直接改動到原本的值
		- **Pointer 可能是 nil/null，需要檢查避免 panic**
		- **在 Go 中，pointer 還涉及 escape analysis（編譯器決定變數該放 stack 還是 heap)**
	- Stack memory vs Heap memory
		- stack 是 LIFO 的堆疊，用來儲存參數、local variable 和 thread 執行 function 時追蹤的其他資料,  呼叫 function 時會 push 一個 frame, return 時會 pop, pop 時**透過移動 stack pointer 安全的釋放記憶體**, **stack 上的資料生命週期受限於 function scope，return 後該 stack frame 就被回收**。 thread stack 是固定的，如果超過限制就會 stack overflow。
		- heap 分配的記憶體不能在 return 時釋放, 所以要避免 leak 和 fragmentation, heap 比 Stack 大很多倍。golang 的所有 goroutin 共享一個 heap，沒辦法存在 Stack 的東西都在裡面, alloc 就用來記錄引用，GC 就是稍後會釋放不再引用的 heap 變數
		- **Stack allocation 更快，因為只需移動 stack pointer**
		- **Heap allocation 需要找到足夠大的連續空間，所以較慢**
		- **Go 的 escape analysis 會自動決定變數要放哪裡（例如 return 一個 local variable 的 pointer 時，該變數會被放到 heap）**
	- Process vs Thread
		- process 是在 OS 上執行的一個程式，thread 則是程序，在一個程式中可能會開啟多個 thread 做並行的處理
		- **Process: 擁有獨立的記憶體空間（code, data, heap, stack）、file descriptors、獨立的資源**
		- **Thread: 共享同一個 process 的記憶體空間（heap, code, data），但各自有獨立的 stack 和 registers**
		- **Thread 間切換成本比 process 低（因為不需要切換記憶體映射）**
		- **Process 間通信需要 IPC（pipe, socket, shared memory），thread 間可以直接存取共享記憶體**
	- **Context switch**
		- 在不同的 **process 或 thread** 之間切換執行
		- 需要保存當前的 CPU 狀態（registers, program counter, stack pointer 等）
		- 載入下一個要執行的 process/thread 的狀態
		- 成本包括：直接成本（保存/恢復狀態）+ 間接成本（cache miss, TLB flush）
		- Go 的 goroutine 比 OS thread 輕量，因為它們在 user space 做 scheduling，減少了 kernel context switch
	- **Mode Switch**（user/kernel mode）是另一個概念：
		- 當 process 需要執行 system call 或處理 interrupt 時發生
		- 從 user mode 切換到 kernel mode（或反之）
		- 這通常會發生在同一個 process 內
- # 記憶體相關
	- Memory Leak
		- **定義：**
		  程式分配的記憶體無法被釋放，持續累積導致可用記憶體減少。
		- **C/C++ 常見原因：**
			- 忘記 free/delete
			- Double free
			- 指標遺失（分配後沒保存 pointer）
		- **Go 常見原因：**
		  即使有 GC，還是可能 leak：
			- Goroutine leak：goroutine 一直 block 無法結束
			- 保持對不再需要的大物件的引用（例如 slice 只用一小部分，但整個底層 array 被保留）
			- Timer/Ticker 沒有 Stop
			- Global map 持續增長沒清理
- # 並發相關
	- Race Condition
		- **定義：**
		  多個 thread/goroutine 同時存取共享資源，且至少有一個是寫入操作，導致結果取決於執行順序。
		- **如何避免：**
			- 使用 Mutex/RWMutex
			- 使用 atomic operations
			- 使用 channel 傳遞資料（Go 的推薦方式："share memory by communicating"）
	- Deadlock
		- **定義：**
		  兩個或多個 thread/goroutine 互相等待對方釋放資源，導致全部卡住。
		-