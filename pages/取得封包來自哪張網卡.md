- 當多張網卡都聽同一個 IP 和 port 時，OS 會複製封包，導致應用程式不知道是哪張網卡收到的。
- `IP_PKTINFO` 是一個 socket 選項，讓你可以在接收封包時獲得**額外的封包信息**，特別是**封包是從哪張網卡接收的**。
- ## IP_PKTINFO
	- ```cpp
	  // 正常接收封包：只能知道發送者的 IP 和 port
	  recvfrom(socket, buffer, size, 0, &sender_addr, &addr_len);
	  // 結果：只知道封包來自 192.168.1.50:12345
	  
	  // 使用 IP_PKTINFO：還能知道封包是從哪張網卡收到的
	  recvmsg(socket, &msg, 0);  // 使用 recvmsg 而不是 recvfrom
	  // 結果：封包來自 192.168.1.50:12345，並且是從 wlan0 (172.21.6.162) 接收的
	  ```
	- ### 啟用 IP_PKTINFO
		- ```cpp
		  // 在創建 socket 後，綁定前設定
		  int enable = 1;
		  if (setsockopt(socket_, IPPROTO_IP, IP_PKTINFO, &enable, sizeof(enable)) < 0) {
		      UVG_LOG_ERROR("Failed to enable IP_PKTINFO");
		  }
		  ```
- ## 核心結構
	- ### 1.  `iovec`  - 數據緩衝區描述
	  
	  ```cpp
	  struct iovec {
	    void  *iov_base;  // 指向數據緩衝區的指標
	    size_t iov_len;   // 緩衝區的大小
	  };
	  
	  // 作用：描述一個內存區域，用於分散/聚集 I/O
	  // 例如：
	  iovec iov;
	  iov.iov_base = my_buffer;     // 指向接收數據的緩衝區
	  iov.iov_len = sizeof(my_buffer);  // 緩衝區大小
	  ```
	- ### 2.  msghdr  - 完整的消息描述
	  
	  ```apl
	  // 作用：描述一個完整的網路消息，包含數據和元數據
	  struct msghdr {
	    void         *msg_name;       // 發送者地址 (sockaddr_in*)
	    socklen_t     msg_namelen;    // 地址結構的大小
	    struct iovec *msg_iov;        // 指向 iovec 數組 (實際數據)
	    size_t        msg_iovlen;     // iovec 數組的元素數量
	    void         *msg_control;    // 控制信息緩衝區 ⭐ 重點
	    size_t        msg_controllen; // 控制信息緩衝區大小
	    int           msg_flags;      // 接收標誌
	  };
	  ```
- ### 3.  `cmsghdr`  - 控制消息頭
  
  ```
  cpp
  
  ```
  struct cmsghdr {
    socklen_t cmsg_len;    *// 控制消息的總長度*
    int       cmsg_level;  *// 協議層級 (如 IPPROTO_IP)*
    int       cmsg_type;   *// 消息類型 (如 IP_PKTINFO)*
    *// 後面跟著實際的控制數據*
  };
  
  *// 作用：在控制信息緩衝區中描述一個控制消息*
  ```
  ```
- ## 🧩 它們如何配合工作
  
  ```
  cpp
  
  ```
  *// 1. 準備接收消息*
  char data_buffer[2048];           *// 實際數據緩衝區*
  char control_buffer[1024];        *// 控制信息緩衝區*
  sockaddr_in sender_addr;          *// 發送者地址*
  
  *// 2. 設定 iovec (描述數據緩衝區)*
  struct iovec iov;
  iov.iov_base = data_buffer;
  iov.iov_len = sizeof(data_buffer);
  
  *// 3. 設定 msghdr (描述整個消息)*
  struct msghdr msg;
  memset(&msg, 0, sizeof(msg));
  msg.msg_name = &sender_addr;           *// 發送者地址*
  msg.msg_namelen = sizeof(sender_addr);
  msg.msg_iov = &iov;                    *// 數據緩衝區描述*
  msg.msg_iovlen = 1;                    *// 只有一個 iovec*
  msg.msg_control = control_buffer;       *// ⭐ 控制信息緩衝區*
  msg.msg_controllen = sizeof(control_buffer);
  
  *// 4. 接收消息*
  ssize_t received = recvmsg(socket, &msg, 0);
  ```
  ```
- ## 🔍 控制信息的結構
  
  ```
  cpp
  
  ```
  *// 控制信息緩衝區的內容：*
  *// [cmsghdr1][data1][cmsghdr2][data2]...*
  
  control_buffer:
  ┌─────────────┬──────────────┬─────────────┬──────────────┐
  │   cmsghdr   │  IP_PKTINFO  │   cmsghdr   │  其他控制數據 │
  │   header    │     data     │   header    │     data     │
  └─────────────┴──────────────┴─────────────┴──────────────┘
  ```
  ```
- ## Flow
	- ```
	  recvmsg() 接收到封包
	             ↓
	  ┌─────────────────────────────────────┐
	  │ msghdr 結構                         │
	  ├─────────────────────────────────────┤
	  │ msg_name: 發送者地址 (192.168.1.50) │
	  │ msg_iov: 實際數據 (RTP 封包)         │
	  │ msg_control: 控制信息緩衝區          │
	  │   ┌─────────────────────────────┐   │
	  │   │ cmsghdr                     │   │
	  │   │ - level: IPPROTO_IP         │   │
	  │   │ - type: IP_PKTINFO          │   │
	  │   │ - data: in_pktinfo          │   │
	  │   │   - ipi_addr: 172.21.10.48  │   │ ← 接收接口 IP
	  │   │   - ipi_ifindex: 3          │   │ ← 接口索引
	  │   └─────────────────────────────┘   │
	  └─────────────────────────────────────┘
	             ↓
	      解析控制信息，提取接口 IP
	             ↓
	      知道封包是從 172.21.10.48 這張網卡收到的
	  ```
	  **iovec**：描述數據緩衝區位置和大小
	  **msghdr**：描述完整消息，包含數據和控制信息
	  **cmsghdr**：描述控制信息中的一個消息
-