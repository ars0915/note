- 當多張網卡都聽同一個 IP 和 port 時，OS 會複製封包，導致應用程式不知道是哪張網卡收到的。
- `IP_PKTINFO` 是一個 socket 選項，讓你可以在接收封包時獲得**額外的封包信息**，特別是**封包是從哪張網卡接收的**。
- ## IP_PKTINFO
	- ```cpp
	  // 正常接收封包：只能知道發送者的 IP 和 port
	  recvfrom(socket, buffer, size, 0, &sender_addr, &addr_len);
	  // 結果：只知道封包來自 192.168.1.50:12345
	  
	  // 使用 IP_PKTINFO：還能知道封包是從哪張網卡收到的
	  recvmsg(socket, &msg, 0);  // 使用 recvmsg 而不是 recvfrom
	  // 結果：封包來自 192.168.1.50:12345，並且是從 wlan0 (172.21.6.162) 接收的
	  ```
	- ### 啟用 IP_PKTINFO
		- ```cpp
		  // 在創建 socket 後，綁定前設定
		  int enable = 1;
		  if (setsockopt(socket_, IPPROTO_IP, IP_PKTINFO, &enable, sizeof(enable)) < 0) {
		      UVG_LOG_ERROR("Failed to enable IP_PKTINFO");
		  }
		  ```
- ## Flow
- ```
  recvmsg() 接收到封包
             ↓
  ┌─────────────────────────────────────┐
  │ msghdr 結構                         │
  ├─────────────────────────────────────┤
  │ msg_name: 發送者地址 (192.168.1.50) │
  │ msg_iov: 實際數據 (RTP 封包)         │
  │ msg_control: 控制信息緩衝區          │
  │   ┌─────────────────────────────┐   │
  │   │ cmsghdr                     │   │
  │   │ - level: IPPROTO_IP         │   │
  │   │ - type: IP_PKTINFO          │   │
  │   │ - data: in_pktinfo          │   │
  │   │   - ipi_addr: 172.21.10.48  │   │ ← 接收接口 IP
  │   │   - ipi_ifindex: 3          │   │ ← 接口索引
  │   └─────────────────────────────┘   │
  └─────────────────────────────────────┘
             ↓
      解析控制信息，提取接口 IP
             ↓
      知道封包是從 172.21.10.48 這張網卡收到的
  ```
  **`iovec`**：描述數據緩衝區位置和大小
- **`msghdr`**：描述完整消息，包含數據和控制信息
- **`cmsghdr`**：描述控制信息中的一個消息